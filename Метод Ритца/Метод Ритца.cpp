// Метод Ритца.cpp: определяет точку входа для консольного приложения
//

#include "stdafx.h"
#include "fstream"
#include "iostream" 
#include "math.h"
using namespace std;
const int n = 20;//число узлов на каждой стороне
double h = 1. / (n - 1);
const int m = (n-2)*(n-2);
double A[m][m];//матрица 
double R[m];//правая часть
double x[m];// столбец решений
void gauss(double a[m][m], double y[m],double x[m])
{ 
	
	double max;
	int k, index;
	const double eps = 0.0000000001;   // точность
	k = 0;
	while (k < m)
	{
		// Поиск строки с максимальным a[i][k]
		max = abs(a[k][k]);
		index = k;
		for (int i = k + 1; i < m; i++)
		{
			if (abs(a[i][k]) > max)
			{
				max = abs(a[i][k]);
				index = i;
			}
		}
		for (int j = 0; j < m; j++)
		{
			double temp = a[k][j];
			a[k][j] = a[index][j];
			a[index][j] = temp;
		}
		double temp = y[k];
		y[k] = y[index];
		y[index] = temp;
		// Нормализация уравнений
		for (int i = k; i < m; i++)
		{
			double temp = a[i][k];
			if (abs(temp) < eps) continue; // для нулевого коэффициента пропустить
			for (int j = 0; j < m; j++)
				a[i][j] = a[i][j] / temp;
			y[i] = y[i] / temp;
			if (i == k)  continue; // уравнение не вычитать само из себя
			for (int j = 0; j < m; j++)
				a[i][j] = a[i][j] - a[k][j];
			y[i] = y[i] - y[k];
		}
		k++;
	}
	// обратная подстановка
	for (k = m - 1; k >= 0; k--)
	{
		x[k] = y[k];
		for (int i = 0; i < k; i++)
			y[i] = y[i] - a[i][k] * x[k];
	}
}



int main()
{
	setlocale(LC_ALL, "Russian");
	ofstream f("input.txt");
	ofstream g("right.txt");
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < m; j++)
		{
			  A[i][j] = 0;
		}
	}
		for(int i=1;i<m;i++)
			for (int j = 1; j < m; j++)
			{ /*Обработка Угловых Ячеек*/
				if (i == 1 && j == 1)
				{
					A[(i - 1)*(n - 2) + j - 1][(i - 1)*(n - 2) + j - 1] += 2. / 3.;//1-1
				}
				 if (i == n-1  && j == n-1)
				{
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += 2./ 3.;//3-3
				}

				 if (i == 1  && j == n-1)
				{
					A[(i - 2)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2. / 3.;//2-2
				}

				 if (i == n-1 && j == 1)
				{
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += 2. / 3.;//4-4
				}
				/*Обработка Граничных*/
				 if (i == 1 && j > 1 && j < n-1) //нижняя
				{
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j -2] += -1. / 6.;//1-4
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 1] += -1. / 6.;//4-1
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2./ 3.;//1-1
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j-2] += 2. / 3.;//4-4

				}
			  if (j == 1 && i > 1 && i < n-1)//левая
				{
					A[(i - 1)*(n - 2) + j- 1][(i - 1)*(n - 2) + j- 1] += 2. / 3.;//1-1
					A[(i - 2)*(n - 2) + j- 1][(i - 1)*(n - 2) + j - 1] += -1. / 6.;//2-1
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j- 1] += -1. / 6.;//1-2
					A[(i - 2)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2. / 3.;//2-2

				}


				if (i == n-1 && j > 1 && j<n-1)// верхняя
				{
					A[(i - 2)*(n - 2) + j-2][(i - 2)*(n - 2) + j-2] += 2. / 3.;//3-3
					A[(i - 2)*(n - 2) + j-2][(i - 2)*(n - 2) + j-1] += -1. / 6.;//3-2
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-2] += -1. / 6.;//2-3
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-1] += 2. / 3.;//2-2

				}

				else if (j == n-1 && i>1 && i < n-1)// правая

				{
					A[(i - 1)*(n - 2) + j-2][(i - 1)*(n - 2) + j- 2] += 2. / 3.;//4-4
					A[(i - 1)*(n - 2) + j-2][(i - 2)*(n - 2) + j - 2] += -1. / 6.;//4-3
					A[(i - 2)*(n - 2) + j - 2][(i - 1)*(n - 2) + j- 2] += -1. / 6.;//3-4
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += 2. / 3.;//3-3
				}
				else if (i > 1 && i < n - 1 && j>1 && j < n - 1)
				{/*Обработка Внутрених Ячеек*/
					/*Базисная функция 1*/
					A[(i - 1)*(n - 2) + j-1][(i - 1)*(n - 2) + j- 1] += 2./ 3.;//1-1
					A[(i - 1)*(n - 2) + j-1][(i - 2)*(n - 2) + j- 1] += - 1. / 6.;//1-2
					A[(i - 1)*(n - 2) + j-1][(i - 2)*(n - 2) + j - 2] += - 1. / 3.; //1-3  
					A[(i - 1)*(n - 2) + j-1][(i - 1)*(n - 2) + j - 2] += -1. / 6.;//1-4
					/*Базисаня функция 2*/
					A[(i - 2)*(n - 2) + j-1][(i - 1)*(n - 2) + j- 1] += -1. / 6.;//2-1
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-1] += 2. / 3.;//2-2
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j - 2] += - 1. / 6.; //2-3  
					A[(i - 2)*(n - 2) + j-1][(i - 1)*(n - 2) + j - 2] += - 1. / 3.;//2-4
					/*Базисная функция 3*/
					A[(i - 2)*(n - 2) + j - 2][(i - 1)*(n - 2) + j- 1] += - 1. / 3.;//3-1
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j- 1] += - 1. / 6.;//3-2
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += 2. / 3.;//3-3 
					A[(i - 2)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += - 1. / 6.;//3-4
					/*Базисная функция 4*/
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 1] += -1. / 6. ;//4-1
					A[(i - 1)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 1] += -1. / 3.;//4-2
					A[(i - 1)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += -1. / 6.;//4-3   
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += 2. / 3.;//4-4
				}
			};


		for (int i = 1; i<m; i++)
		{
			for (int j = 1; j<m; j++)
			{
				f << A[i][j] << " "; // вывод матрицы в файл
			}
			f << '\n';
		}
	//правая часть
		for (int i = 1; i <= m; i++)
		{
			R[i] = 0;  //Формирование правой части 
		};

		for (int i = 1; i<m; i++)
			for (int j = 1; j<m; j++)
			{ /*Обработка Угловых Ячеек*/
				if (i == 1 && j == 1)
				{
					R[(i - 1)*(n - 2) + j - 1] += 1. / 4.*h*h; // левая нижняя
				}
				 if (i == n - 1 && j == n - 1)
				{
					 R[(i - 2)*(n - 2) + j - 1] += 1. / 4.*h*h;// правая верхняя
				}

				 if (i == 1 && j == n - 1)
				{
					 R[(i - 2)*(n - 2) + j - 2] += 1. / 4.*h*h;// левая верхняя
				}

				 if (i == n - 1 && j == 1)
				{
					 R[(i - 1)*(n - 2) + j - 2] += 1. / 4.*h*h;// правая нижняя
				}
				/*Обработка Граничных*/
				 if (i == 1 && j > 1 && j < n - 1) //нижняя
				{
					 R[(i - 1)*(n - 2) + j - 1] += 1. / 4.*h*h;// 1
					 R[(i - 1)*(n - 2) + j - 2] += 1. / 4.*h*h;// 4
				}
				  if (j == 1 && i > 1 && i < n - 1)//левая
				{
					  R[(i - 1)*(n - 2) + j - 1] += 1. / 4.*h*h;//1

					  R[(i - 2)*(n - 2) + j - 1] += 1. / 4.*h*h;//2

				}


				 if (i == n - 1 && j > 1 && j<n - 1)// верхняя
				{
					 R[(i - 2)*(n - 2) + j - 1] += 1. /4.*h*h;//2

					 R[(i - 2)*(n - 2) + j - 2] += 1. /4.*h*h;//3

				}

				 if (j == n - 1 && i>1 && i < n - 1)// правая

				{
					 R[(i - 2)*(n - 2) + j - 2] += 1. / 4.*h*h;//3

					 R[(i - 1)*(n - 2) + j - 2] += 1. / 4.*h*h;//4
					
				}
				 if (i > 1 && i < n - 1 && j>1 && j < n - 1)
				{/*Обработка Внутрених Ячеек*/
					R[(i - 1)*(n - 2) + j - 1] += 1. / 4.*h*h;//1

					R[(i - 2)*(n - 2) + j - 1] += 1. / 4.*h*h ;//2

					R[(i - 2)*(n - 2) + j - 2] += 1. / 4.*h*h ;//3

					R[(i - 1)*(n - 2) + j - 2] += 1. / 4.*h*h ;//4
				}
			};
	
		for (int i = 0; i < m; i++)
		{
			 g << R[i] << "\n"; // Правая часть в файл
		}
		gauss(A, R,x);
		for (int i = 0; i < m; i++)
			cout << "x[" << i << "]=" << x[i] << endl;// вывод решения 
			
		g.close();
		f.close(); 
		getchar();
		getchar();
    return 0;
}

