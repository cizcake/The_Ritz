// Метод Ритца.cpp: определяет точку входа для консольного приложения
//

#include "stdafx.h"
#include "fstream"
#include "iostream" 
#include "math.h"
using namespace std;
const int n = 4;//число узлов на каждой стороне
double h = 1. / (n - 1);
const int m = (n-2)*(n-2);
double A[m][m];//матрица 
double R[m];//правая часть
double x[m];// столбец решений
void gauss(double a[m][m], double y[m],double x[m])
{ 
	
	double max;
	int k, index;
	const double eps = 0.0001;   // точность
	k = 0;
	while (k < m)
	{
		// Поиск строки с максимальным a[i][k]
		max = abs(a[k][k]);
		index = k;
		for (int i = k + 1; i < m; i++)
		{
			if (abs(a[i][k]) > max)
			{
				max = abs(a[i][k]);
				index = i;
			}
		}
		for (int j = 0; j < m; j++)
		{
			double temp = a[k][j];
			a[k][j] = a[index][j];
			a[index][j] = temp;
		}
		double temp = y[k];
		y[k] = y[index];
		y[index] = temp;
		// Нормализация уравнений
		for (int i = k; i < m; i++)
		{
			double temp = a[i][k];
			if (abs(temp) < eps) continue; // для нулевого коэффициента пропустить
			for (int j = 0; j < n; j++)
				a[i][j] = a[i][j] / temp;
			y[i] = y[i] / temp;
			if (i == k)  continue; // уравнение не вычитать само из себя
			for (int j = 0; j < m; j++)
				a[i][j] = a[i][j] - a[k][j];
			y[i] = y[i] - y[k];
		}
		k++;
	}
	// обратная подстановка
	for (k = m - 1; k >= 0; k--)
	{
		x[k] = y[k];
		for (int i = 0; i < k; i++)
			y[i] = y[i] - a[i][k] * x[k];
	}
}



int main()
{
	setlocale(LC_ALL, "Russian");
	ofstream f("input.txt");
	ofstream g("right.txt");
	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < m; j++)
		{
			  A[i][j] = 0;
		}
	}
		for(int i=1;i<m;i++)
			for (int j = 1; j < m; j++)
			{ /*Обработка Угловых Ячеек*/
				if (i == 1 && j == 1)
				{
					A[(i - 1)*(n - 2) + j - 1][(i - 1)*(n - 2) + j - 1] += 2. / 3.;
				}
				else if (i == n-1  && j == n-1)
				{
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += 2./ 3.;
				}

				else if (i == 1  && j == n-1)
				{
					A[(i - 2)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2. / 3.;
				}

				else if (i == n-1 && j == 1)
				{
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += 2. / 3.;
				}
				/*Обработка Граничных*/
				else if (i == 1 && j > 1 && j < n-1) //нижняя
				{
					A[(i - 1)*(n - 2) + j - 1][(i - 1)*(n - 2) + j -2] += 2. / 3.;
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2. / 3.;
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += -1. / 6.;
					A[(i - 1)*(n - 2) + j - 1][(i - 1)*(n - 2) + j-2] += -1. / 6.;

				}
				else  if (j == 1 && i > 1 && i < n-1)//левая
				{
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-1] += 2. / 3.;
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j - 1] += -1. / 6.;
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j-1] += -1. / 6.;
					A[(i - 1)*(n - 2) + j - 1][(i - 2)*(n - 2) + j - 1] += 2. / 3.;

				}


				else if (i == n-1 && j > 1 && j<n-1)// верхняя
				{
					A[(i - 2)*(n - 2) + j-2][(i - 1)*(n - 2) + j-1] += 2. / 3.;
					A[(i - 2)*(n - 2) + j-2][(i - 2)*(n - 2) + j-2] += -1. / 6.;
					A[(i - 2)*(n - 2) + j-1][(i - 1)*(n - 2) + j-1] += -1. / 6.;
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-2] += 2. / 3.;

				}

				else if (j == n-1 && i>1 && i < n-1)// правая

				{
					A[(i - 1)*(n - 2) + j-2][(i - 1)*(n - 2) + j-1] += 2. / 3.;
					A[(i - 1)*(n - 2) + j-2][(i - 1)*(n - 2) + j - 2] += -1. / 6.;
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j-2] += -1. / 6.;
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 1] += 2. / 3.;
				}
				else if (i > 1 && i < n - 1 && j>1 && j < n - 1)
				{/*Обработка Внутрених Ячеек*/
					A[(i - 1)*(n - 2) + j-1][(i - 1)*(n - 2) + j-1] += 2./ 3.;
					A[(i - 1)*(n - 2) + j-1][(i - 2)*(n - 2) + j-1] += - 1. / 6.;
					A[(i - 1)*(n - 2) + j-1][(i - 2)*(n - 2) + j - 2] += - 1. / 3.;   // ФИ1
					A[(i - 1)*(n - 2) + j-1][(i - 1)*(n - 2) + j - 2] += -1. / 6.;

					A[(i - 2)*(n - 2) + j-1][(i - 1)*(n - 2) + j-1] += - 1. / 6.;
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j-1] += 2. / 3.;
					A[(i - 2)*(n - 2) + j-1][(i - 2)*(n - 2) + j - 2] += - 1. / 6.;   // ФИ2
					A[(i - 2)*(n - 2) + j-1][(i - 1)*(n - 2) + j - 2] += - 1. / 3.;

					A[(i - 2)*(n - 2) + j - 2][(i - 1)*(n - 2) + j-1] += - 1. / 3.;
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j-1] += - 1. / 6.;
					A[(i - 2)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += 2. / 3.;   // Фи3
					A[(i - 2)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += - 1. / 6.;

					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j-1] += -1. / 6. ;
					A[(i - 1)*(n - 2) + j - 2][(i - 2)*(n - 2) + j-1] += -1. / 3.;
					A[(i - 1)*(n - 2) + j - 2][(i - 2)*(n - 2) + j - 2] += -1. / 6.;    // Фи4
					A[(i - 1)*(n - 2) + j - 2][(i - 1)*(n - 2) + j - 2] += 2. / 3.;
				}
			};


		for (int i = 1; i<m; i++)
		{
			for (int j = 1; j<m; j++)
			{
				f << A[i][j] << " "; // вывод матрицы в файл
			}
			f << '\n';
		}
	//правая часть
		for (int i = 1; i <= m; i++)
		{
			R[i] = 0;  //Формирование правой части 
		};

		for (int i = 1; i<m; i++)
			for (int j = 1; j<m; j++)
			{
				if (i == 1 && j == 1)
				{
					R[(i - 1)*(n - 2) + j - 1] += (1. / 4.*h*h);
				}
				 if (i == n - 1 && j == n - 1)
				{
					 R[(i - 2)*(n - 2) + j - 1] += (1. / 4.*h*h);
				}

				 if (i == 1 && j == n - 1)
				{
					 R[(i - 2)*(n - 2) + j - 2] += (1. / 4.*h*h);
				}

				 if (i == n - 1 && j == 1)
				{
					 R[(i - 1)*(n - 2) + j - 2] += (1. / 4.*h*h);
				}
				/*Обработка Граничных*/
				 if (i == 1 && j > 1 && j < n - 1) //нижняя
				{
					 R[(i - 1)*(n - 2) + j - 1] += (1. / 4.*h*h);
					 R[(i - 1)*(n - 2) + j - 2] += (1. / 4.*h*h);
				}
				  if (j == 1 && i > 1 && i < n - 1)//левая
				{
					  R[(i - 1)*(n - 2) + j - 1] += (1. / 4.*h*h);

					  R[(i - 2)*(n - 2) + j - 1] += (1. / 4.*h*h);

				}


				 if (i == n - 1 && j > 1 && j<n - 1)// верхняя
				{
					 R[(i - 2)*(n - 2) + j - 1] += (1. / 4.*h*h);

					 R[(i - 2)*(n - 2) + j - 2] += (1. / 4.*h*h);

				}

				 if (j == n - 1 && i>1 && i < n - 1)// правая

				{
					 R[(i - 2)*(n - 2) + j - 2] += (1. / 4.*h*h);

					 R[(i - 1)*(n - 2) + j - 2] += (1. / 4.*h*h);
					
				}
				 if (i > 1 && i < n - 1 && j>1 && j < n - 1)
				{/*Обработка Внутрених Ячеек*/
					 R[(i - 1)*(n - 2) + j - 1] += (1. / 4.*h*h);

					R[(i - 2)*(n - 2) + j - 1] += (1. / 4.*h*h) ;

					R[(i - 2)*(n - 2) + j - 2] += (1. / 4.*h*h) ;

					R[(i - 1)*(n - 2) + j - 2] += (1. / 4.*h*h) ;
				}
			};
	
		for (int i = 0; i < m; i++)
		{
			 g << R[i] << "\n"; // Правая часть в файл
		}
		gauss(A, R,x);
		for (int i = 0; i < m; i++)
			cout << "x[" << i << "]=" << x[i] << endl;// вывод решения 
			
		g.close();
		f.close(); 
		getchar();
		getchar();
    return 0;
}

